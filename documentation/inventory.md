# INVENTORY

This is a reference for code included in the `inventory` app. It is recommended to read the README.md from this directory first.

`inventory` is a conventional Django app that uses templates to render pages, with no ReactJS components and only some minimal JavaScript.  Most of the views either render pages listing database items, or process form data to create or update them. Here, Django forms are used both to render the form HTML, and to sanitize/validate the data. It makes more sense to discuss inventory not by views (as there are too many of them), but by features/functionalities, so this is how this part of the documentation is organised past the general information.
- [Where the static files are](#sf)
- [Views directory intro](#views)
- [Templates](#templates)
- [Basic functionalities (managing simple CRUD operations)](#basic)
- [Tracking usage over time](#usage)
- [Dispense testing](#dt)
- [Locate lists of compounds / availability checks](#locate)
- [Data lookups and comparing plates](#browse)
## Static files<a name="sf"></a>

Because of how the cookiecuter template settings are configured, the static files of the inventory app (some css and js) are located in `webSoakDB_frontend/static/inventory` directory. Should've fixed that - sorry.

## `submitDelete()` JavaScript function
Script used whenever user clicks a button that would delete something from the database. It creates a dialog box asking for confirmation and prevents form submission if user chooses 'Cancel'.

## `views` directory<a name="views"></a>

Instead of the `views.py` file, the app has a `views` directory, which contains both files with the views, and files with helper functions used only by those views. The original view.py file had over 900 lines and was difficult to navigate.

### Files with views

**`libraries.py`** - views for listing, creating and updating libraries
**`plates.py`** - views for listing, creating and updating library plates; including dispense testing and tracking usage over time
**`presets.py`** - views for listing, creating and updating presets
**`queries.py`** - views for searching and processing data: checking availability of compounds, looking up single items
**`other.py`** - views for managing projects and users, displaying error messages and everything else

### Other files in the `inventory/views` directory:
**`dt.py`** - helper functions used by the dispense testing process only
**`inv_helpers.py`** - other helper functions written for `inventory` views

## Templates<a name="templates"></a>

The function of most templates does not require explanation. The few less obvious ones are:

**`chck-rd-fill.html`, `chck-sqr-fill.html`, `chevron-down.html`, `chevron-up.html`, `x-sqr.html`** - svg icons from Bootstrap Icons (https://icons.getbootstrap.com/) included in various other templates.

**`availability-details.html`** - code rendering one row of availability table (with a nested table inside it), showing the results of availability search for one subset of compounds

**`availability-table.html`** - a table displaying availability details for a set of subsets; used for projects and presets, renders an `availability-details.html`element for each subset

**`molecule-image.html`** - produces a small clickable 2D structure image of a molecule, which opens a compounds detail page for the molecule in a new tab/window. Used in various places in the inventory interface. The image itself is generated by `serve_2d()` function in the `webSoakDB_backend` app using RDKit tools.

**`overlay.html`** - a semi-transparent overlay element included in various other templates, together with JavaScript scripts that manage it. By default it is invisible, but the provided `showOverlay()` function make it appear and cover the whole page, with a box saying "Processing data. Please wait", preventing the user from clicking anything. The overlay is used for submitting forms that may take a while to process, to provide clear feedback to the user. It stays on the page until the automatic reload after form submission.

`showOverlay()` takes a list of ids as an argument - these are ids of the obligatory form inputs. It checks if all of the necessary fields are filled before showing the overlay - otherwise, in situation where user fails to submit all required values, HTML validation would prevent form submission, but the overlay would appear anyway, providing misleading feedback (there is no data processing going on in this situation), and making it impossible to corret the errors in the form until user manually reloads the page.

## Basic functionalities: views displaying, creating and deleting elements (with views and URLs responsible for each)<a name="basic"></a>

### Libraries:

In-house libraries are listed by the `libraries()` view (url: `inventory/libraries`), each with a list of library plates belonging to it underneath. For every library, two forms are rendered: one for editing (using `edit_library()'/` view at `inventory/edit-library/` url), and the other for deleting ( `delete_library()` at `inventory/delete-library/`). These forms are by default hidden and are only shown after clicking the “edit/delete” button (achieved by a simple JavaScript script manipulating the CSS classes of the forms). Each form contains a hidden input submitting the id of the item that it modifies - to the user, delete form is only a button. The layout is very similar for presets.

To prevent accidental data removal, `delete_library()` only deletes a library if it has no library plates associated with it - otherwise it redirects to an error page instructing the user to delete all the plates first (rendered by `library_deletion_error()` at `inventory/library-deletion-error/`). The `libraries()` page also provides a form for creating a new library (sending data to `add-library()` at `inventory/add-library/`)

### Library plates:

The plates from in-house libraries are listed under each library in the `libraries()` view without any details or tools to manage them. The main starting point for managing plates is `plates()` at `inventory/plates/` : it provides a table listing all the in-house library plates, each with two links: one for accessing detail view for the plate, and one for tracking usage patterns (discussed as a separate feature below). (Note: For private library plates, such links are provided too, but not on the `plates()` page, but the page of the project in which the plate is used ). Above the table with the plates list, there is a `<select>` element that allows for filtering the plates by library (simple JavaScript function; in the template file). The page with the list also provides a form for creating a new library plate ( `add_plate()` at `inventory/add-plate/`) and deleting multiple library plates at once ( `delete_multiple_plates()` at `inventory/delete-multiple-plates/`), especially useful when deleting the whole library, which requires deleting all its plates first.

The detailed view of one library plate is provided by `update-plate()` at `update-plate/<int:pk>/`. The central element of the page is a table listing all the compounds (SourceWell instances) in the plate. It has a `<select>` element allowing to filter out available of unavailable compounds, similar to that which allows filtering plates by library. The view displays some information and statistics about the plate contents on the left, and provides several other tools:

* downloading plate map (links to at `download_current_plate_map()` at `/downloads/plate-map/<int:pk>`; part of webSoakDB_backend app)
* form to upload dispense testing mapping file and redirect to dispense testing interface (discussed as a separate feature below)
* form to mark single compounds as unavailable manually (outside of dispense testing). There are two ways of doing it:
	- user can manually tick a checkbox next to the desired compounds in the table
	- user can use the 'Mark as unavailable' form  - when he or she types in the well name and presses enter, a `findAndCheck()` JavaScript function checks the appropriate checkbox
	In both cases, a moment after checking the checkbox, the table row containing it is moved to the top of the table, so all the selected compounds are listed together ( `moveToTop()` script).
	
	Actually, the whole table with the compounds is at the same time an HTML form. It does not have its own 'submit' button: instead form submission is launched with the 'Mark all selected compounds as unavailable' button in the 'Mark as unavailable' section using the `submitInactive()` JS function, which sends the form data to the `deactivate_compounds_manually()` view at `inventory/deactivate-compounds-manually/`.
	
* buttons to mark unavailable compounds as available (appear inside the table in rows showing unavailable compounds). These buttons launch the `submitActive()` JS function, which sends the compound data to `activate_single_compound()` at `inventory/activate-single-compound/`. To prevent nesting HTML forms inside one another (the whole table is a form), the `submitActive()` function creates the JavaSctipt `formData` object from scratch, based on the function's argument and template variables.
* Form for editing the plate data (not source well data). The submission is managed by `edit_plate()` view at `inventory/edit-plate/`. Note: in some cases (e.g. changing the "current" status), editing a plate results in updating cached histograms, which may take more time than one expects with a simple edit - therefore submitting this form triggers showing the overlay element.
* Form for registering a plate opening event - in case a staff member opened the plate in non-routine circumstances and wants to note it. The form sends data to `open_plate()` view at `inventory/open_plate/`, which creates a new instance of `PlateOpening` related to the plate
* A button for deleting the plate (in fact a form with a hidden input), which submits the plate id to `delete_plate()` at `inventory/delete-plate/`.

Plates for private library plates are listed on the project lookup page, with links to the "update plate" page and usage tracking page (sometimes a user's plate might be stored in XChem, and an availability check might be requested, e.g. to see if some of the solution have dried up after a long time).

### Presets

The presets page ( `presets()`  at `inventory/presets`) is organised in a very similar way to the libraries page: it lists all the presets in the table and has hidden forms to edit ( `edit_preset()` at `inventory/edit-preset/`) and delete ( `delete_preset()` at `inventory/delete-preset`) them, and also features a form to create a new one ( `add_preset()` at `inventory/add-preset`). Additionaly, for each preset there is a link to availability information (this feature is discussed in detail below).


**Note on updating and creating  presets:** the form creating a preset only allows for adding compounds from one library (adding one LibrarySubset). To create a preset covering multiple libraries, user first needs to create the preset with one subset, and the edit it to add more. If a preset already contains a selection from a particular library and the user wants to update this selection, the old selection is completely overwritten by the new one. The old LibrarySubset is first deleted from the database, then new one is created based on the uplodaded file and added to the Preset. E.g. if user wants to add three compounds to the list, the new uploaded list needs to contain all the old compounds + the three new ones.

### Users

The link to user management is found not directly on the inventory home page, but on `inventory/browse-data/`.

`manage_users()` at `inventory/users` is only concerned with staff members and power user prvileges. Power users are going to be regular XChem users who are not Diamond employees, but have a lot of experience with the facilities and should be allowed more access to their own data (for example, manual editing of experimental data, which is normally supposed to be limited to staff members). The specific permissions are not yet decided. It will be up to the staff to decide who should have power user permissions.

At the moment only the staff member part is functional. 

- `add_staff_member()` at `inventory/add-staff-member/` can either create a new Django User with the submitted FedID as the username with staff permissions, or if the username is already registered, change the user's staff status to true; if additional information about the existing user (such as name and email) is not already in the database, the information typed into the form will be added; if it is already there, it will NOT be overwritten (at the moment the only way to overwrite user's data is in the Django admin panel - should be changed)

- `remove_from_staff()` at `invenroty/remove-staff-member/` is sent the user's id (the button in the interface triggers submission of a form with hidden inputs) and sets the user's staff status to false - it does NOT remove the User object from the database. If there is only one staff member left, the view will refuse to take away its staff privileges.

Users are authenticated using CAS, and permissions to specific projects are managed outside of XChemSPA.

### Proposals/Projects

Managing projects starts from the `projects()` view at `/inventory/projects/`, which has two parts: a form for creating a new project, and a form leading to a look-up page for a specific project.

- `add_project()` at `inventory/project/` creates a new Project object, as well as the first `IspybAuthorization` object related to it, which authorizes users to access visit 1 of the proposal submitted for the project.

- The `proposal()` view at `inventory/proposal` leads to a project look-up found based on the proposal string submitted in the form. The view provides:

	- list of library plates of private (user-submitted) libraries with links to `update-plate()` view and usage tracking view for each
	- list of all subsets chosen for the project (both user's own cherry-picking lists and presets) with availability information
	- list of all the visits registered for XChemSPA, and a form to create a new one ( `add_visit()` at `inventory/add-visit`); registering a new visit in XChemSPA creates new `IspybAuthorization` object linked to the project

**TODO:  link to managing the experiment**

## Advanced features:
	
### Tracking plate usage across time <a name="tracking"></a>
	
Each library plate in the list at `inventory/plates` has a link labelled “track usage”, which allows ‘travelling back in time’ to see which compounds in a plate were available at a given date. The page  with the information also contains a visual representation of the library plate.

- `track_usage()` (url: `inventory/track-usage/<int:pk>/<str:date>/<str:mode>/`)- this view copies values from the relevant SourceWell objects into new temporary objects, sets their `active` attribute to how it was on the inspected date (based on the records stored in SWStatuschange objects), and feeds the modified data into the template.

url args:
- `pk`: the id of the tracked plate
- `date`: the date to be inspected in the format yyyy-mm-dd
- `mode`: the desired layout of the page, the argument can be either “general-view”, which shows various additional information about the plate, and “graphic-view”, which only provides the visual representation and buttons to navigate to other dates
	
E.g. `inventory/track-usage/8/2021-02-12/graphic-view/` shows what compounds were available on 12th February 2021 in plate with the id of 8, in the mode showing only the visual representation.

#### Notes on the visual representation:

**Appearance:**
The library plate is represented as an HTML table where green cells represent wells with available compounds, and red cells represent wells where the unavailable compounds used to be. The cells also display the name of the well. If a well is not included in the plate map, the cell representing it is empty. When users places the cursor over  a cell, the cursor disappears and the cell expands to make the well name easier to read - this is implemented in CSS.

**The HTML table vs. library plates (the physical objects)**
There are three types of library plates used in the lab; two of them (384 LDV and 384PP) have 384 wells organized in 24 columns (1-24) and 16 rows (A-P), and one (1536LDV) has 1536 wells organised into 48 columns (1-48) and 32 rows (A-AF). Therefore, the HTML table representing the plate can have two sizes with the corresponding number of rows and columns. The well names are combinations of the row and column names, e.g. ‘A13’, ‘AB01’. Note: in case of 384LDV, the actual physical layout of the wells is slightly different from what the table looks like, so it should be treated more like a schematic diagram of it than an attempt to mimic the appearance of the plate (unlike dispense testing interface).

The view determines the size of the table to show based on well names: if it finds a name that is too “high” for a 384-well plate (like S32), it renders the table with 1536 wells/cells. This means that if the library plate is physically stored in a 1536LDV plate, but only happens to use wells available in 384-well plates (i.e. the top left quarter of the plate), it will be represented as a 384-well table anyway.

**How the representation is rendered:**
The view renders an empty HTML table of the appropriate size, where every cell has the well name as its id. In a hidden `<section>`, it also renders a `<div>` element representing each `SourceWell` object belonging to the plate, with the class determined by whether it is available or not, and the well name stored in 'data-well' HTML attribute. On page load, the `arrange()` JavaScript function places each `<div>` representing a `SourceWell` in the corresponding table cell by matching the `data-well` attribute with the cell `id`. The function is in the template itself. Cells representing unused wells stay unchanged.

**The dates**
The link to the `track_usage()` page in the plate list (produced by the `plates()` view) directs to the page showing the current state of the plate in question. The date inspected is the last time the availability of any of the compounds in the plate (`SourceWell` objects) was updated (based on the `last_tested` attribute of the plate). From the tracking page, there are two ways of moving onto a different date:
-a drop-down list of dates - this produces a selection of all dates on which there were changes in availability recorded
-a date input allowing for selecting an arbitrary date
When a date is selected by any of those input elements, it launches the `redirect()` script (included in the template), which redirects to the appropriate URL for his date and the same display mode

**Display modes (general-view vs. graphic-view):**
In both modes, the rendered HTML is almost the same. The `<main>` element in the page has a different id depending on the mode, and there are different CSS rules written for `<main>` and its child elements depending on id (mostly, some of the elements have `display: none` attribute in the graphic-view). The mode also affects the URLs to which user is redirected and the link to switching modes.

## DISPENSE TESTING <a name="dt"></a>

Dispense testing is a process in which each compound in a library plate is dispensed onto a crystallisation plate in order to check if it still gets dispensed or if the plate has run out of it. The inventory app provides a visual interface to easily record missing compounds. The user marks empty wells on the image of a destination plate, and based on the submitted file, the application finds out what compounds were supposed to go there, and marks those compounds as unavailable.  There are two views involved in the process:

- `dispense_testing_map()` - a view that processes the file that that maps source wells (the wells in the library plate) to destination wells (the wells in the crystallisation plate into which those compounds are dispensed) and then renders the interface for marking compounds as unavailable
- `deactivate_compounds()` - a view that processes the data submitted through the dispense testing page


### Mapping source wells to destination wells
The page rendered by `update_plate()` contains a form in which the user submits the mapping file. The data from the form is submitted to the `dispense_testing_map()` view.

#### File format and well naming conventions in the crystallisation plate:
The submitted file must be a CSV file where the relevant columns have the headers “source well” and “destination well” (the script detecting the headers is not case sensitive and discards leading and trailing white space, so a name like “ Destination Well “ is also recognised). The order of the columns or the presence of other columns does not matter. Thus, **the dispense testing feature can re-use the file that is used by Echo dispenser for the same test**.
The script accepts two naming conventions of the destination wells: one that is used in the Echo file, and one that follows the marking that are physically on the plate (that I will call “human readable” here, and that are described that way in the source code too). Thus, if there is ever a need to manually create the file, or if dispensers used start recognising the human-readable naming system, there will be no need to manually convert names into the Echo system to create an input file for the dispense testing feature.

Dispense testing uses only one type of crystallisation plate: SWISSCI 3 Lens Crystallisation Plate (specs and photos available [here]( https://swissci.com/wp-content/uploads/2020/03/3-Lens-plate.pdf) )
In the plate, the wells are organised into groups of three with one reservoir, like in the ASCII art below (where a, c, and d are wells, and r is a resevoir).
	
```
----------
|(a) [r] | 
|        |
|(c) (d) |
----------
```
	
These groups are placed in 12 columns (marked 1-12) and 8 rows (marked A-H). The markings “a” “c” and “d” are not on the plate itself, but are commonly used. Well names are composed of the row name, column name and the letter a, c, or d specifying the position in the group, e.g. B7c, F12a or G3d.
The naming used in the Echo input files does not take groups into account and considers each column and row separately, which makes 24 columns (1-24) and 16 rows (A-P), giving names such as G16, P3 etc. The conversion between the Echo naming system and the “human readable” naming system follows a pattern like this:
	
```
A1a --> A1  --------------------------
A1c --> B1  | (A1a / A1)    [r / A2]|
A1d --> B2  |                       |
A2a --> A3  | (A1c / B1) (A1d / B2) |
A2c --> B3  |-----------------------|
```
	
etc.

After the file upload, the script creates a dictionary matching source well to destination plate. If the uploaded file uses Echo-style well names (so, in practice, the only method used right now), they get converted to “human-readable” names first.
	

#### The interface to mark unavailable compounds
Once the dictionary mapping the wells is created, `dispense_testing_map()` renders a page with the dispense testing interface. The main element of the page is a form rendered as an HTML table representing the crystallisation plate, which roughly mimics its layout and appearance, with individual wells represented by checkboxes, and reservoirs represented by an icon of an ‘x’ in a square (they do not “do” anything, they are there to provide a closer visual representation of the plate). The check-boxes representing inactive SourceWells are checked on load.

	
In case of errors in the upload file, error messages are displayed instead of the input form. 

During the test, users inspect the destination plate to check for wells into which no compound was dispensed. If they find such a well, they mark it on the plate with a marker. Then, in the interface, they check all the boxes representing the marked wells and submit the data. In rare cases, a compound that was not dispensed in the previous test may reappear - in that case users uncheck the pre-checked box. 
As the compounds are selected for deactivation, they also appear in a table listing them, including the code and source plate (JS script in the template). There is also a list of compounds that were already unavailable.

#### Rendering the form:
First, the table is rendered with `<label>`s but no check-boxes: each group of 3 wells and a reservoir is a `<div>` inside a table cell. Each label’s id is the “human-readable” style name of the well. The check-boxes are rendered separately, with HTML `id`s containing the name of the appropriate destination well, and the `data-` attributes containing information about the compound. The `arrange()` script, which launches on page load, places them in the appropriate positions in the table/form based on ids of the label and the checkbox (script in the template). The form also includes a hidden input field with a list of all the ids of the already inactive SourceWells.

#### Saving the data:
After submitting the form, the data is directed to `deactivate_compounds()`. The data includes:
* plate id
* ids of all the SourceWells from which the compounds were not dispensed ('not dispensed')
* ids of all the SourceWell from which compounds were not expected to be dispensed, i.e. which were already inactive before the test ('already missing')

For every SourceWell from 'not dispensed', if it is active, its `active` attribute is set to `False`, `deactivation_date` is set the current date, and a new SWStatuschange is created*. If it is already inactive, it is ignored.
Then the application checks if all the compounds from 'already missing' list are present in the 'not dispensed' list. If not (i.e. if any inactive SourceWell turned out to still have some compound in it), they are marked back as active, the `deactivation_date` is set to `None`, and a SwStatuschange is created*. 

In the end, the  `last_tested` attribute of the plate is changed to the current time stamp, and if the plate tested is a current plate, histograms of the corresponding library are updated. The user is redirected back to 'update/delete' plate page.


*Note: the application cannot simply compare the 'not dispensed' list to the list of all the inactive SourceWells in the plate taken directly from the database. In case of a larger library, it takes two or three crystallisation plates to test all the compounds. A SourceWell may be absent from the 'not dispensed' list not because it is still available, but because it was not tested at all in this part of the test.

**Note on status changes:**
The application will not create more than one SWStatuschange on the same day. If, on the same day, a SourceWell is set to active, and then it is set back to inactive or vice versa, the application treats it as an act of correcting a mistake, and undoes the last change. This mean that the last (today's) SWStatuschange is deleted, and `deactivation_date` as well as `active` are restored to the state from before both changes. This avoids ambiuity in tracking the changes over time. If the same change were made twice in a row (which not should happen in normal running of the application), the second one would just be ignored. 

## Locating compound lists - availability check feature<a name="locate"></a>

If an experiment does not require using the whole library but only a selection of compounds, it is preferable to use one of the older, more used-up plates in order to save the current one. The availability check feature helps deciding if this is a viable option, and if yes, which of the older plates would be the best to use for this particular set of compounds. To simplify, it gets a list of compounds selected from the library and checks every library plate to see how many of them are not available in it (details below). Then, it produces a list of library plates, stating  which of the desired compounds are not available in any particular plate.

The are four uses of this feature in XChemSPA:
- On the 'Presets' page, the table with the preset list provides links to an availability check for each preset
- The proposal page features availability checks for all the subsets selected for the project
- 'Locate compounds' page allows for uploading a list of compounds without saving it in the database as a subset, and generating availability information for it
- In the React application, in the SoakDB export form, links to availability information page are provided for each selected subset (if there are any)

I will describe how the check works, and then list all the views and pages responsible for it in each case.

### Ranking algorithm and 'recommended plate'

The list of plates with availability information is provided to the user ordered from the "best" to the "worst" plate. Before I explain how the search is performed, I will explain how the plates are ranked.

In case of libraries that fit into one plate, it is quite simple: the best plate is the one that misses the fewest compounds from the list. The availability is checked in all plates, and the best 10 are presented to the user (if there are fewer than 10 plates, they will all be presented). The best plate is displayed to the user as "recommended plate". There is only one complication: if there is more than one plate that has the highest availability of the compounds, the algorithm makes sure to recommend the plate that is not the current one. For example, if the list of plates has the current plate at the first place with 86% availability, and at the second place is an old plate, also with 86% availability, these plate will be swapped.

For libraries that take up more than 1 plate (DSI Poised with ethylene glycol is a real-life example, taking up 3 plates), it is more complicated. The ranking starts the same way: first availability is checked for every plate. Then, availability in each combination of two plates is checked, and then three etc. - if the library takes up *n* plates, combinations of up to *n* plates are checked. However, there is an exception: whenever a plate, or plate combination is found to have 100% of the desired compounds, the search doesn't move to combinations of a higher number of plates. So, for example, if a user wishes to use 80 compounds from DSI-P in ethylene glycol, and the algorithm finds 50 of them in one plate, and the other 30 in another one, it will never get to the stage where it inspects three-plate combinations.

Just like in case of single plates, there is a preference for recommending old plates (or combinations that do not contain current plates).

***Why not try to find a minimum set of plates that would have all the compounds from a list, or as many as possible?***

The problem is probably an example of set cover problem (https://en.wikipedia.org/wiki/Set_cover_problem), though there is a possibility that something about the data structure decreases its computational complexity. In either case, creating an approximation or an algorithm with acceptable performance would take a lot of time, and this is not an essential feature, so I decided to focus on something else. Still, it looks like something users might ask about in future.

### Generating availability information

The main entity responsible for generating the availability information is the class SubsetCopyWithAvailability (found in `tools/data_storage_classes`). The views that provide availability information pass a set of relevant subsets to the `get_subsets_with_availability()` function (defined in `inv_helpers.py`), which returns instances of `SubsetCopyWithAvailability`, or if it is just one subset, they pass it to the constructor of `SubsetCopyWithAvailability`. The methods defined in this class and called by `__init__()` are responsible for creating the availability information.


`SubsetCopyWithAvailability` has attributes based on the LibrarySubset model  (and its foreign keys), plus the `availability` attribute. The constructor of `SubsetCopyWithAvailability` can take either an instance of `LibrarySubset` model, or a list of compounds **and** a Library model instance. In the former case, it copies the attributes from the `LibrarySubset` instance, and in the latter, it sets the list of compounds as its own `compounds` and copies Library attributes into its own library-related attributes. Then, in both cases, the `availability` attribute is set using the `get_compound_availability()` method.

`get_compound_availability()` first checks how many plates the library spans based on the number of current plates(for most libraries, it's just one), and directs the rest of the process accordingly. For both single- and multi-plate library, the process starts with launching `rank_single_plates()`. This method creates instances of `PlateCopy`, which is a similar kind of class to `SubsetCopyWithAvailability` - it stores values copied from `LibraryPlate` with added extra information in the `missing_compounds` and `availability` attributes. The difference is that `PlateCopy` does not have any method that computes these values- they are is generated by `SubsetCopyWithAvailability.get_plate_copy()` and either passed to the constructor of `PlateCopy` or set as a new attribute. After `rank_single_plates()` creates `PlateCopy` objects for every plate in the relevant  library, it sorts them by availability(with the mentioned preference for non-current plates), and such a list is returned to `get_compound_availability()`.

If the library involved is stored in only one plate, the first 10 items of the ranked list become the `availability` attribute of the created instance of `SubsetCopyWithAvailability`. If it covers more plates, and none of the ranked single plates contains all of the desired compounds, `get_compound_availability()` launches `rank_combinations()`. This method first creates all possible combinations of 2 plates from the library, and then uses them to create instances of `CombinedPlate` - a class that stores combined data from a list of `PlateCopy` objects (e.g. its `compounds` attribute stores a set of all the `SourceWell` objects from all the plates passed to the  `CombinedPlate`'s constructor). Then, the CombinedPlate is passed to `get_plate_copy()` and processed in the same way as LibraryPlate model instance would be processed, making `PlateCopy` instances that are in fact copies of not one, but two plates. If no combination with 100% compound availability is found, the process is repeated for 3 plates, etc. until it reaches the limit (the number of plates needed to keep the whole library in). 
The function returns the top 10 `PlateCopy` objects with the best availability of the desired compounds (Note: these objects can be either based on (single) LibraryPlate objects, or on a CombinedPlate object), and they become the `availability` of the `SubsetCopyWithAvailability`.

To describe the process itself, without the reference to models, classes and methods:

1. The algorithm gets a list of desired compounds from a certain library

2. A copy of that list and its related metadata is created

3. For every plate in the library:
	i. a copy of the plate data is created
	ii. the list of desired compounds is compared to the compounds available in the plate to find out which compounds are missing
	iii. the list of missing compounds is added to the copy of the plate data
	
4. If the library takes up more than one plate, and no single plate has all the desired compounds:
	5. combinations of plates are created
	6. fictional plates are created, whose data combine data from a combination of plates
	7. For every such combination, the process in step 3 is repreated
(step 4 can involve making combinations of more and more plates)

.8. Copies of plates (or plate combination) are ranked by the best availability (i.e. which copy has the fewest compounds missing)

.9. The list of ten best plate/combination copies is added to the copy of the list of compounds

Thus, an instance of  `SubsetCopyWithAvailability` object is ready to be passed to a view and displayed.

The information stored in  `SubsetCopyWithAvailability` if the following:
```
id - (int) copied from LibrarySubset or "0"
name - (str) copied from LibrarySubset or "temporary selection"
library -  (Library) copied from LibrarySubset or passed directly
library_id - (int) copied from LibrarySubset or Library
library_name - (str) copied from LibrarySubset or Library
compounds - (list of Compounds or BasicTemporaryCompound) copied from LibrarySubset or passed
availability - (list of PlateCopy) generated by get_compound_availability()			
	PlateCopy:
	id - (int) copied from Plate or CombinedPlate
	library - (Library) copied from Plate or CombinedPlate
	barcode - (str) copied from Plate or CombinedPlate
	name - (str) copied from Plate or CombinedPlate
	current - (bool) copied from Plate or CombinedPlate
	missing_compounds - (list of Compounds) passed directly
	availability - (float) added after the istance is created
```
"passed directly" is short for "passed directly to the constructor when an instance is created".  When user uploads  a list of compounds without saving it, it is automatically assigned the id of "0" the name of "temporary selection."

### The views that provide availability information:

#### `locate_compounds()` (in `queries.py`)
The page has a form where the user selects a library and uploads a list of SMILES strings (which should belong to compounds in the library). After validating the file, it is passed, together with the selected library id, to `upload_temporary_subset()`. That function creates a list of BasicTemporaryCompound objects based on the SMILES strings from the file. These objects store the code and the SMILES string of corresponding Compounds objects in a library. If the library has more that one code for the SMILES string (yes, it happens), the first one that's found is used.
The view then passes the selected library, and the generated list of BasicTemporaryCompound objects to `get_subsets_with_availability()`. This produces an instance of SubsetCopyWithAvailability, which is passed to the template.
#### `subset_availability()`(in `queries.py`)
This view is linked from SoakDB export form - each subset which requires selecting a library plate for it has a separate link to this view. It is meant to help the user with the choice. It finds a subset based on the id in the URL argument, and passes it to `get_subsets_with_availability()`. The resulting instance of SubsetCopyWithAvailability is passed to the template.
**TODO: Provide the same kind of links in XChemSPA, on the "Sources" page.**
#### `proposal()` (in `other.py`)
Getting to this page starts with the `projects()` view. User submits a proposal string to a form, which is sent to the `proposal()` view. The view finds the project and passes all the subsets in it to `get_subsets_with_availability()`. The resulting instance of SubsetCopyWithAvailability is passed to the template together with other data relating to the project.
#### `preset_availability()` (in  `presets.py`)
Every preset on the "Presets" page has a link to this view. It finds the Preset based on id in the URL, and passes it to `fake_preset_copy()`. This function creates a PresetCopy instance, which stores the id, name and description copied from it. Then for every subset in the preset, it creates a SubsetCopyWithAvailability and adds it to PresetCopy.subsets - so Preset copy is a copy of the Preset with SubsetCopyWithAvailability instances instead of Subset instances linked to it. The PresetCopy this created is passed to the template.

## Extra data browsing: searching for compounds and plates, comparing plates<a name="browse"></a>
The inventory app provides a few simple search functions to quickly access specific information. The views can be found in `queries.py`.
### `browse_data()`
A simple page that provides links to specific searches.
### `compound_lookup()`
A place listing all the data related to a single compound. **Note:** it lists compound locations, but only in public plates - it skips user's own plates.
### `find_single_compound()`
Provides a search function where the user enters a code or a SMILES string into a box, and the view retrieves all the Compounds that have that code or SMILES string. For every compound found, it provides a link to the `compound_lookup()` page for it.
When a string is submitted to the view, it first checks if it's a SMILES string (it "borrows" `parse_smiles()` from `validators.py`, which returns None when it is passed a valid SMILES string). Then, it either find all the compounds with the given code, or converts the SMILES string to the form used in the database, and then retrieves the compounds with that string. Thus, the search can find the right compound even if the notation convention of the SMILES entered by the user is different from the one stored in the database.
### `find_plate()`
Provides a search bar for finding a table by its barcode.

### `compare_plates()`
A feature that allows finding what two library plates are in common. The user selects two library plates from a drop-down list and submits them to a view. The view compares the compounds to find how many and what compounds the plates have in common, list all the compounds that have the same SMILES strings but different codes and calculates simple stats.

### `get_subset_map()`
Produces a CSV file with a plate map of a library plate, but only including compounds that belong to a specific subset. The tables with availability data all provide a link to this file for every plate.
