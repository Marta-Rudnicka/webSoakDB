# INVENTORY

This is a reference for code included in the `inventory` app. It is recommended to read the README.md first.

`inventory` is a conventional Django app that uses templates to render pages, with no ReactJS components and only some minimal JavaScript.  Most of the views either render pages listing database items, or process form data to create or update them. Here, Django forms are used both to render the form HTML, and to sanitise/validate the data. It makes more sense to discuss inventory not by views (as there are too many of them), but by features/functionalities, so this is how this part of the documentation is organised past the general information.

## Static files

Because of how the cookiecuter template settings are configured, the static files of the inventory app (some css and js) are located in `webSoakDB_frontend/static/inventory` directory. Should've fixed that - sorry.

## `submitDelete()` JavaScript function
Script used whenever user clicks a button that would delete something from the database. It creates a dialog box asking for confirmation and prevents form submission if user chooses 'Cancel'.

## `views` directory

Instead of the `views.py` file, the app has a `views` directory, which contains both files with the views, and files with helper functions used only by those views. The original view.py file had over 900 lines and was difficult to navigate.

### Files with views

**`libraries.py`** - views for listing, creating and updating libraries
**`plates.py`** - views for listing, creating and updating library plates; including dispense testing and tracking usage over time
**`presets.py`** - views for listing, creating and updating presets
**`queries.py`** - views for searching and processing data: checking availability of compounds, looking up single items
**`other.py`** - views for managing projects and users, displaying error messages and everything else

### Other files in views:
**`dt.py`** - helper functions used by the dispense testing process only
**`inv_helpers.py`** - other helper functions written for `inventory` views

## Templates

Most of the templates does not require explanation - they provide the `main` block for `layout.html` for partivulat views. The few less obvious ones are:

**`chck-rd-fill.html`, `chck-sqr-fill.html`, `chevron-down.html`, `chevron-up.html`, `x-sqr.html`** - svg icons from Bootstrap Icons (https://icons.getbootstrap.com/) included in various other templates.

**`availability-details.html`** - code rendering one row of availability table (with a nested table inside it), showing the results of availability search for one subset of compounds: the library plate data, and the list of missing molecules (as clickable images). For each listed library plate, it provides a link to the `get_subset_map()` view, which creates a donwloadable CSV file listing the locations of all the compounds from that subset in the table (or a plate map but including only the compounds from the subset)

**`availability-table.html`** - a table displaying availability details for a set of subsets; used for projects and presets, renders an `availability-details.html`element for each subset

**`molecule-image.html`** - produces a small clickable 2D structure image of a molecule, which opens a compounds detail page for the molecule in a new tab/window. Used in various places in the invetory interface. The image itself is generated by `serve_2d()` function in the `webSoakDB_backend` app using RDKit tools.

**`overlay.html`** - a semi-transparent overlay element included in various other templates, together with JavaScript scripts that manage it. By default it is invisible, but the provided `showOverlay()` function make it appear and cover the whole page, with a box saying "Processing data. Please wait", preventing the user from clicking anything. The overlay is used for submitting forms that may take a while to process, to provide clear feedback to the user. It stays on the page until the automatic reload after form submission.

`showOverlay()` takes a list of ids as an argument - these are ids of the obligatory form inputs. It checks if all of the necessary fields are filled before showing the overlay - otherwise, in situation where user fails to submit all required values, HTML validation would prevent form submission, but the overlay would appear anyway, providing misleading feedback (there is no data processing going on in this situation), and making it impossible to corret the errors in the form until user manually reloads the page.

## Basic functionalities: views displaying, creating and deleting elements (whith views and URLs responsible for each)

### Libraries:

In-house libraries are listed by the `libraries()` view (url: `inventory/libraries`), each with a list of library plates belonging to it underneath. For every library, two forms are rendered: one for editing (using `edit_library()'/` view at `inventory/edit-library/` url), and the other for deleting ( `delete_library()` at `inventory/delete-library/`). These forms are by default hidden and are only shown after clicking the “edit/delete” button (achieved by a simple JavaScript script manipulating the CSS classes of the forms). Each form contains a hidden input submitting the id of the item that it modifies - to the user, delete form is only a button. The forms layout is are very similar for presets.

To prevent accidental data removal, `delete_library()` only deletes a library if it has no library plates associated with it - otherwise it redirects to an error page instructing the user to delete all the plates first (rendered by `library_deletion_error()` at `inventory/library-deletion-error/`). The `libraries()` page also provides a form for creating a new library (sending data to `add-library()` at `inventory/add-library/`)

### Library plates:

The plates from in-house libraries are listed under each library in the `libraries()` view without any details or tools to manage them. The main starting point for managing plates is `plates()` at `inventory/plates/` : it provides a table listing all the in-house library plates, each with two links: one for accessing detail view for the pate, and one for tracking usage patterns (discussed as a separate feature below). (Note: For private library plates, such links are provided too, but not on the `plates()` page, but the page of the project in which the plate is used ). Above the table with the plates list, there is a `<select>` element that allows for filtering the plates by library (simple JavaScript; in the template file). The page with the list also provides a form for creating a new library plate ( `add_plate()` at `inventory/add-plate/`) and deleting multiple library plates at once ( `delete_multiple_plates()` at `inventory/delete-multiple-plates/`), especially useful when deleting the whole library, which requires deleting all its plates first.

The detailed view of one library plate is provided by `update-plate()` at `update-plate/<int:pk>/`. The central element of the page is a table listing all the compounds (SourceWell instances) in the plate. It has a `<select>` element allowing to filter out available of unavailable compounds, similar to that which allows filtering plates by library. The view displays some informtion and statistics about the plate contents on the left, and provides several other tools:

* downloading plate map (links to at `download_current_plate_map()` at `/downloads/plate-map/<int:pk>`; part of webSoakDB_backend app)
* form to upload dispense testing mapping file and redirect to dispense testing interface (discussed as a separate feature below)
* form to mark single compounds as unavailable manually (outside of dispense testing). There are two ways of doing it:
	- user can manually tick a checkbox next to the desired compounds in the table
	- user can use the 'Mark as unavailable' form  - when he or she types in the well name and presses enter, a `findAndCheck()` JavaScript function checks the appropriate checkbox
	In both cases, a moment after checking the checkbox, the table row containing it is moved to the top of the table, so all the selected compounds are listed together ( `moveToTop()` script).
	
	Actually, the whole table with the compounds is at the same time a HTML table. It does not have its own 'submit' button: instead form submission is launched with the 'Mark all selected compounds as unavailable' button in the 'Mark as unavailable' section using the `submitInactive()` JS function, which sends the form data to the `deactivate_compounds_manually()` view at `inventory/deactivate-compounds-manually/`.
	
* buttons to mark unavailable compounds as available (appear inside the table in rows showing unavailable compounds). These buttons launch the `submitActive()` JS function, which sends the compound data to `activate_single_compound()` at `inventory/activate-single-compound/`. To prevent nesting HTML forms inside one another (the whole table is a form), the `submitActive()` function creates the formData object from scratch, based on the function argument and template variables.
* Form for editing the plate data (not source well data). The submission is managed by `edit_plate()` view at `inventory/edit-plate/`. Note: in some cases (e.g. changing the "current" status), editing a plate results in updating cached histograms, which may take more time than one expects with a simple edit - therefore submitting this form triggers showing the overlay lement.
* Form for registing a plate opening event - in case a staff member opened the plate in non-routine circumstances and wants to note it. The form sends data to `open_plate()` view at `inventory/open_plate/`, which creates a new instance of PlateOpening relate to the plate
* A button for deleting the plate (in fact a form with a hidden input), which submits the plate id to `delete_plate()` at `inventory/delete-plate/`.

Plates for private library plates are listed on the project lookup page, with links to the "update plate" page and usage tracking page (sometimes a user's plate might be stored in XChem, and an availability check might be requested, e.g. to see if some of the solution have dried up after a long time).

###Presets

The presets page ( `presets()`  at `inventory/presets`) is organised in a very similar way to the libraries page: it lists all the presets in the table and has hidden forms to edit ( `edit_preset()` at `inventory/edit-preset/`) and delete ( `delete_preset()` at `inventory/delete-preset`)them, and also features a form to create a new one ( `add_preset()` at `inventory/add-preset`). Additionaly, for each preset there is a link to availability information (this feature is discussed in detail below).


**Note on updating creating or presets:** the form creating a preset only allows for adding compounds from one library (adding one LibrarySubset). To create a preset covering multiple libraries, user first needs to create the preset with one subset, and the edit it to add more. If a preset already contains a selection from a particular library and the user wants to update this selection, the old selection is completely overwritten by the new one. The old LibrarySubset is first deleted from the database, then new one is created based on the uplodaded file and added to the Preset. E.g. if user wants to add three compounds to the list, the new uploaded list needs to contain all the old compounds + the three new ones.

###Users

The link to user management is found not directly on the inventory home page, but on `inventory/browse-data/`.

`manage_users()` at `inventory/users` is only concerned with staff members and power user prvileges. Power users are going to be regular XChem users who are not Diamond employees, but have a lot of experience with the facilities and should be allowed more access to their own data (for example, manual editing of experimental data, which is normally supposed to be limited to staff members). The specific permissions are not yet decided. It will be up to the staff to decide who should have power user permissions.

At the moment only the staff member part is functional. 

- `add_staff_member()` at `inventory/add-staff-member/` can either create a new Django User with the submitted FedID as the username with staff permissions, or if the username is already registered, change the user's staff status to true; if additional information about the existing user (such as name and email) is not already in the database, the information typed into the form will be added; if it is already there, it will NOT be overwritte (at the moment the only way to overwrite user's data is in the Django admin panel)

- `remove_from_staff()` at `invenroty/remove-staff-member/` is sent the user's id (the button in the inerface triggers submission of form with hidden inputs) and sets the user's staff status to false - it does NOT remove the User object from the database
#TODO prevent removing the last staff member!!! 

Users are authenticated using CAS, and permissions to specific projects are managed outside of XChemSPA.

###Proposals/Projects

Managing projects starts from the `projects()` view at `/inventory/projects/`, which has two parts: a form for creating a new project, and a form leading to a look-up page for a specific project.

- `add_project()` at `inventory/project/` creates a new Project object, as well as the first `IspybAuthorization` object related to it, which authorizes users to access visit 1 of the proposal submitted for the project.

- The `proposal()` view at `inventory/proposal` leads to a project look-up found based on the proposal string submitted in the form. The view provides:

* list of library plates of private (user-submitted) libraries with links to `update-plate()` view and usage tracking view for each
* list of all subsets chosen for the project (both user's own cherry-picking lists and presets) with availability information
* list of all the visits registered for XChemSPA, and a form to create a new one ( `add_visit()` at `inventory/add-visit`); registering a new visit in XChemSPA creates new `IspybAuthorization` object linked to the project
* TODO: link to managing the experiment

###Compounds

- `compound_lookup()` at `inventory/compound-lookup/<int:pk>/` displays all the details of a compound, together with a struture image and information on where it is physically located. The location information includes only public library plates

##Simple searches

- `find_single_compound()` at `inventory/find-single-compound/` - provides search form and search results for finding compounds by SMILES string or the code. Both kinds of string are entered into the same field; SMILES string are converted to the standardised form used everywhere else before the executing the query
- `find-library-plate()` provides search form and search results for looking up a library plate by barcode
- `compare_plates()` at `inventory/compare-plates/` provides a form in which two of public library plates can be selected. When the form is submitted, provides various information allowing to compare plates, such as the overlap between the compounds, different names for the same compounds in each plates (if there are any) etc.

## Navigation pages

`index()` view at `inventory/` serves the inventory home page, and `browse_data()` at `inventory/browse-data/` provides links to user management and search pages.

## `Advanced features:
	
### Tracking plate usage across time
	
Each library plate in the list at `inventory/plates` has a link labelled “track usage”, which allows ‘travelling back in time’ to see which compounds in a plate were available at a given date. The page  with the information also contains a visual representation of the library plate.

- `track_usage()` (url: `inventory/track-usage/<int:pk>/<str:date>/<str:mode>/`)- this view copies values from the relevant SourceWell objects into new temporary objects, sets their `active` attribute to how it was on the inspected date (based on the records stored in SWStatuschange objects), and feeds the modified data into the template.

url args:
- pk: the id of the tracked plate
- date: the date to be inspected in the format yyyy-mm-dd
- mode: the desired layout of the page, the argument can be either “general-view”, which shows a various additional information about the plate, and “graphic-view”, which only provides the visual representation and buttons to navigate to other dates
	
E.g. `inventory/track-usage/8/2021-02-12/graphic-view/` shows what compounds were available on 12th February 2021 in plate with the id of 8, in the mode showing only the visual representation.

#### Notes on the visual representation:

**Appearance:**
The library plate is represented as an HTML table where green cells represent wells with available compounds, and red cells represent wells where the unavailable compounds used to be. The cells also display the name of the well. If a well is not included in the plate map, the cell representing it is empty. When users places the cursor over over a cell, the cursor disappears and the cell expands to make the well name easier to read - this is implemented in CSS.

**The HTML table vs. library plates (the physical objects)**
There are three types of library plates used in the lab; two of them (384 LDV and 384PP) have 384 wells organized in 24 columns (1-24) and 16 rows (A-P), and one (1536LDV) has 1536 wells organised into 48 columns (1-48) and 32 rows (A-AF). Therefore, the HTML table representing the plate can have two sizes with the corresponding number of rows and columns. The well names are combinations of the row and column names, e.g. ‘A13’, ‘AB01’. Note: in case of 384LDV, the actual physical layout of the wells is slightly different from what the table looks like, so it should be treated more like a schematic diagram of than an attempt to mimic the appearance of the plate (unlike dispense testing interface).

The view determines the size of the table to use based on well names: if it finds a name that is too “high” for a 384-well plate like S32, it renders the table with 1536 wells/cells. This means that if the library plate is physically stored in a 1536LDV plate, but only happens to use wells available in 384-well plates (i.e. the top left quarter of the plate), it will be represented as a 384-well table anyway.

**How the representation is rendered:**
The view renders an empty HTML table of the appropriate size, where every cell has the well name as its id. In a hidden <section>, it also renders a `<div>` element representing each `SourceWell` object belonging to the plate, with the class determined by whether it is available or not, and the well name stored in 'data-well' HTML attribute. On page load, the `arrange()` JavaScript function places each `<div>` representing a `SourceWell` in the corresponding table cell by matching the `data-well` attribute with the cell `id`. The function is in the template itself. Cells representing unused wells stay unchanged.

**The dates**
The link to the `track_usage()` page in the plate list (produced by the `plates()` view) directs to the page showing the current state of the plate in question. The date inspected is the last time the availability of any of the compounds in the plate (`SourceWell` objects) was updated (based on the last_tested attribute of the plate). From the tracking page, there are two ways of moving onto a different date:
-a drop-down list of dates - this produces a selection of all dates on which there were changes in availability recorded
-a date input allowing for selecting an arbitrary date
When a date is selected by any of those input elements, it launches the `redirect()` script (included in the template), which redirects to the appropriate URL for his date and the same display style as the previous page

**Display modes (general-view vs. graphic-view):**
In both modes, the rendered HTML is almost the same. The <main> element in the page has a different id depending on the mode, and there are different CSS rules written for <main> and its child elements depending on id (mostly, some of the elements have ```display: none``` attribute in the graphic-view). The mode also affects the URLs to which user is redirected and the link to switching modes.

## DISPENSE TESTING

Dispense testing is a process in which each compound in a library plate is dispensed onto a crystallisation plate in order to check if it still gets dispensed or if the plate has run out of it. The inventory app provides a visual interface to easily record missing compounds. The user marks empty wells on the image of a destination plate, and based on the submitted file, the application finds out what compounds were supposed to go there, and marks those compounds as unavailable.  There are two views involved in the process:

- `dispense_testing_map()` - a view that processes the file that that maps source wells (the wells in the library plate) to destination wells (the wells in the crystallisation plate into which those compounds are dispensed) and then renders the interface for marking compounds as unavailable
- `deactivate_compounds()` - a view that processes the data submitted through the dispense testing page


### Mapping source wells to destination wells
The page rendered by `update_plate()` contains a form in which the user submits the mapping file. The data from the form is submitted to the `dispense_testing_map()` view.

#### File format and well naming conventions in the crystallisation plate:
The submitted file must be a CSV file where the relevant columns have the headers “source well” and “destination well” (the script detecting the headers is not case sensitive and discards leading and trailing white space, so a name like “ Destination Well “ is also recognised). The order of the columns or the presence of other columns does not matter. Thus, **the dispense testing feature can re-use the file that is used by Echo dispenser for the same test**.
The script accepts two naming conventions of the destination wells: one that is used in the Echo file, and one that follows the marking that are physically on the plate (that I will call “human readable” here, and that are described that way in the source code too). Thus, if there is ever a need to manually create the file, or if dispensers used start recognising the human-readable naming system, there will be no need to manually convert names into the Echo system to create an input file for the dispense testing feature.

Dispense testing uses only one type of crystallisation plate: SWISSCI 3 Lens Crystallisation Plate (specs and photos available here: https://swissci.com/wp-content/uploads/2020/03/3-Lens-plate.pdf) 
In the plate, the wells are organised into groups of three with one reservoir, like in the ASCII art below (where a, c, and d are wells, and r is a resevoir).
	
```
----------
|(a) [r] | 
|        |
|(c) (d) |
----------
```
	
These groups are placed in 12 columns (marked 1-12) and 8 rows (marked A-H). The markings “a” “c” and “d” are not on the plate itself, but are commonly used. Well names are composed of the row name, column name and the letter a, c, or d specifying the position in the group, e.g. B7c, F12a or G3d.
The naming used in the Echo input files does not take groups into account and considers each column and row separately, which make 24 columns (1-24) and 16 rows (A-P), giving names such as G16, P3 etc. The conversion between the Echo naming system and the “human readable” naming system follows a pattern like this:
	
```
A1a --> A1  --------------------------
A1c --> B1  | (A1a / A1)    [r / A2]|
A1d --> B2  |                       |
A2a --> A3  | (A1c / B1) (A1d / B2) |
A2c --> B3  |-----------------------|
```
	
etc.

After the file upload, the script creates a dictionary matching source well to destination plate. If the uploaded file uses Echo-style well names, they get converted to “human-readable” names first.
	

#### The interface to mark unavailable compounds
Once the dictionary mapping the wells is created, `dispense_testing_map()` renders a page with the dispense testing interface. The main element of the page is a form rendered as an HTML table representing the crystallisation plate, which roughly mimics its layout and appearance, with individual wells represented by checkboxes, and reservoirs represented by an icon of an ‘x’ in a square (they do not “do” anything, they are there to provide a closer visual representation of the plate). The checkboxes representing inactive SourceWells are checked on load.

	
In case of errors in the upload file, error messages are displayed instead of the input form. 

During the test, users inspect the destination plate to check for wells into which no compound was dispensed. If they find such a well, they mark it on the plate with a marker. Then, in the interface, they check all the boxes representing the marked wells and submit the data. In rare cases, a compound that was not dispensed in the previous test may appear - in that case users uncheck the pre-checked box. The image below shows a photograph of a fragment of the real plate next to the data from that plate correctly entered into the form:
As the compounds are selected for deactivation, they also appear in a table listing them, including the code and source plate (JS script in the template). There is also a list of compounds that were already unavailable.

#### Rendering the form:
First, the table is rendered with <label>s but no checkboxes: each group of 3 wells and a reservoir is a <div> inside a table cell. Each label’s id is the “human-readable” style name of the well. The checkboxes are rendered separately, with HTML `id`s containing the name of the appropriate destination well, and the `data-` attributes containing information about the compound. The `arrange()` script, which launches on page load, places them in the appropriate positions in the table/form based on ids of the label and the checkbox (script in the template). The form also includes a hidden input field with a list of all the ids of the already inactive SourceWells.

#### Saving the data:
After submitting the form, the data is directed to `deactivate_compounds()`. The data includes:
* plate id
* ids of all the SourceWells from which the compounds were not dispensed ('not dispensed')
* ids of all the SourceWell from which compounds were not expected to be dispensed, i.e. which were already inactive before the test ('already missing')
For every SourceWell from 'not dispensed', if it is active, its `active` attribute is set to `False`, `deactivation_date` is set the current date, and a new SWStatuschange is created*. If it is already inactive, it is ignored.
Then the application checks if all the compounds from 'already missing' list are present in the 'not dispensed' list. If not (i.e. if any inactive SourceWell turned out to still have some compound in it), they are marked back as active, the `deactivation_date` is set to `None`, and a SwStatuschange is created*. 

Note: the application cannot simply compare the 'not dispensed' list to the list of all the inactive SourceWells in the plate taken directly from the database. In case of a larger library, it takes two or three crystallisation plates to test all the compounds. A SourceWell may be absent from the 'not dispensed' list not because it was dispensed, but because it was not tested at all in this part of the test.

**Note on status changes:**
The application will not create more than one SWStatuschange on the same day. If, on the same day, a SourceWell is set to active, and then it is set back to inactive or vice versa, the application treats it as an act of correcting a mistake, and undoes the last change. This mean that the last (today's) SWStatuschange is deleted, and `deactivation_date` as well as `active` are restored to the state from before both changes. This avoids ambiuity in tracking the changes over time. If the same change were made twice in a row (which not should happen in normal running of the application), the second one would just be ignored. 

In the end, the the `last_tested` attribute of the plate is changed to the current time stamp, and id the plate tested is a current plate, histograms of the corresponding library are updated. The user is redirected back to 'update/delete' plate page.


## Locating compound lists - availability check feature

If an experiment does not require using the whole library but only a selection of compounds, it is preferable to use one of the older, more used-up plates in order to save the current one. The availability check feature helps deciding if this is a viable option, and if yes, which of the older plates would be the best to use for this particular set of compounds. To simplify, it gets a list of compounds selected from the library and checks every library plate to see how many of them are not available in it (details are discussed later on). Then, it shows the user the list of library plates, with the information on which of the desired compounds are not available in this particular plate.

The are four uses of this feature in XChemSPA:
- On the 'Presets' page, the table with the presets list provides links to an availability check for each preset
- The proposal page features availability checks for all the subsets selected for the project
- 'Locate compounds` allows for uploading a list of compunds without saving it in the database as subset, and generating availability information for it
- In the React application, in the SoakDB export form, links to availability information page is provided for each selected subset (if there are any)

I will describe how the check works, and then list all the views and pages responsible for it in each case.

### Ranking algorithm and 'recommended plate'

The list of plates with availability information is provided to the user ordered from the "best" to the "worst" plate. Before I explain how the search is performed, I will explain how the plates are ranked.

In case of libraries that fit into one plate, it is quite simple: the best plate is the one that misses the fewest compounds from the list. The availability is checked in all plates, and the best 10 are presented to the user (if there are fewer than 10 plates, they will all be presented). The best plate is displayed to the user as "recommended plate". There is only one complication: if there is more than one plate that has the highest availability of the compounds, the algorithm makes sure to recommend the plate that is not the current one. For example, if the list of plates has the current plate at the first place with 86% availability, and at the second place is an old plate, also with 86% availability, these plate will be swapped and the old one will be recommended.

For libraries that take up more than 1 plate (DSI Poised with ethylene glycol is a real-life example, taking up 3 plates), it is more complicated. The ranking starts the same way: first availability is checked for in every plate. Then, availability in each combination of two plates is checked, and then three etc. - if the library takes up *n* plates, combinations of up to *n* plates are checked. However, there is an exception: whenever a plate, or plate combination is found to have 100% of the desired compounds, the search doesn't move to combinations of a higher number of plates. So, for example, if a user wishes to use 80 compounds from DSI-P in ethylene glycol, and the algorithm finds 50 of them in one plate, and the other 30 in another one, it will never get to the stage where it inspects three-plate combinations.

Just like in case of single plates, there is a preference for recommending old plates (or combinations that do not contain current plates).

***Why not try to find a minimum set of plates that would have all the compounds from a list, or as many as possible?***

The problem is probably an example of set cover problem (https://en.wikipedia.org/wiki/Set_cover_problem), though there is a possibility that something about the data structure decreases its computational complexity. In either case, creating an approximation or an algorithm with acceptable performance would take a lot of time, and this is not an essential feature. Still, it looks like something users might ask about in future.

### Generating availability information

The main entity responsible for generating the availability information is the class `SubsetCopyWithAvailability` (found in `tools/data_storage_classes`). The views that provide availability information pass a set of relevant subsets to the `get_subsets_with_availability()` function (defined in `inv_helpers.py`), which creates and returns instances of `SubsetCopyWithAvailability`. The methods defined in this class are responsible for creating the availability information.

`SubsetCopyWithAvailability` has attributes based on the LibrarySubset model attributes (and its foreign keys), plus the `availability` attribute. The constructor of `SubsetCopyWithAvailability` can take either take either an instance of LibrarySubset model, or a list of compounds **and** a Library model instance. In the former case, it copies the attributes from the LibrarySubset instance, and in the latter, it sets the list of compounds as its own `compounds`, copies Library attributes into its own library-related attrubutes. Then, in both cases, the `availability` attribute is set using the `get_compound_availability()` method.

`get_compound_availability()` first checks how many plates the library spans based on the number of current plates(for most libraries, it's just one), and directs the rest of the process accordingly. For both single- and multi-plate library, the process starts with launching `rank_single_plates()`. This method creates instances of `PlateCopy`, which is a similar kind of class to `SubsetCopyWithAvailability` - it stores values copied from `LibraryPlate` with added extra information in the `missing_compounds` and `availability` attributes. The difference is that `PlateCopy` does not have any method that computes these values- they are is generated by `SubsetCopyWithAvailability.get_plate_copy()` and either passed to the constructor of `PlateCopy` or set as a new attribute. After `rank_single_plates()` creates `PlateCopy` objects for every plate in the library related to the  LibrarySubset, it sorts them by availability(with the mentioned preference for non-current plates), and such a list is returned to `get_compound_availability()`.

If the library involved is stored in only one plate, the first 10 items of the ranked list become the `availability` attribute of the new instance of `SubsetCopyWithAvailability`. If it covers more plates, and none of the ranked single plates contains all of the desired compounds, `get_compound_availability()` launches `rank_combinations()`. This method first creates all possible combinations of 2 plates from the library, and then uses them to create instances of `CombinedPlate` - a class that stores combined data from a list of `PlateCopy` objects (e.g. its `compounds` attribute stores a set of all the `SourceWell` objects from all the plates passed to the  `CombinedPlate`'s constructor). Then, the CombinedPlate is passed to `get_plate_copy()` and processed in the same way as LibraryPlate model instance would be processed, making `PlateCopy` instances that are in fact copies of not one, but two plates. If no combination with 100% compound availability is found, the process is repeated for 3 plates, etc. until it reaches the limit (the number of plates needed to keep the whole library in). 
The function returns the top 10 `PlateCopy` objects with the best availability of the desired compounds (Note: these objects can be either based on one LibraryPlate objects, or on a CombinedPlate object), and they become the `availability` of the new `SubsetCopyWithAvailability`.

To describe the process itself, without the reference to models, classes and methods:

1. The algorithm gets a list of desired compounds from a certain library

2. A copy of that list and its related metadata is created

3. For every plate in the library:
	i. a copy of the plate data is created
	ii. the list of desired compounds is compared to the compounds available in the plate to find out which compounds are missing
	iii. the list of missing compounds is added to the copy of the plate data
	
4. If the library takes up more than one plate, and no single plate has all the desired compounds:
	i. combinations of plates are created
	ii. fictional plates are created, whose data combine data from each combination of plates
	iii. For every such combination, the process in step 3 is repreated
(step 4 can involve making combinations of more and more plates)

5. Copies of plates (or plate combination) are ranked by the best availability (i.e. which copy has the fewest compounds missing)

6. The list of ten best plate/combination copies is added to the copy of the list of compounds

### Specific views providing compound availability information:

*** views where SubsetCopyWithAvailability objects are created from LibrarySubset objects***

The constructor ( `__init__`) of `SubsetCopyWithAvailability` can take two kinds of arguments. The first kind is just an instance of the `LibrarySubset` model - the values are simply copied from the LibrarySubset, (or generated based on it)


- `proposal()` at `inventory/proposal` - creates a `SubsetCopyWithAvailability` object for every LibrarySubset selected for the project, and passes it to the template; the template displays this information in `availability-table.html` subtemplate

- `preset_availability()` at `inventory/preset-availability/<int:pk>/` creates `SubsetCopyWithAvailability` objects for each subset in the preset and displays them in the `availability-details.html` subtemplate. The "presets" page provides links to this view for each preset in the main table.

- `subset_availability()` at `inventory/compound-availability/<int:pk>/` creates `SubsetCopyWithAvailability` for one subset; this page is linked from the SoakDB Export form in the React app. ***TODO: the same links should be provided in the experiment management app, on the page managing importing compounds from the inventory***

*** the view where there is no LibrarySubset to copy from***

The alternative way to create a new `SubsetCopyWithAvailability` is passing a list of `Compounds` model instances, and a `Library` instance to the constructor. This is done in one special case, where the desired selection of compounds is not supposed to be saved in the database as a `LibrarySubset`. The passed list of compounds becomes the value `SubsetCopyWithAvailability.compound`, and the library-related attributes are copied from the library.

- `locate_compounds()` view at `inventory/locate-compounds/` provides tools to check availability of any list of compounds. It provides a form in which the user selects the library to search and uploads a file listing the SMILES strings of the desired compounds. After validating the form, the application creates a set of copies of compounds matching both the selected library, and the SMILES string from the file. Then the compounds and the library are used to create a `SubsetCopyWithAvailability` (so, in a way, a copy of a non-existent subset is created). During the creation, all the usual availability information is created. `SubsetCopyWithAvailability` is passed to the template, where it is presented in `availability-table.html` subtemplate.
